# 🧑‍💻 알면 좋은 것들

## Category

[SET](#set)

[DFS 구현 방식](#DFS-구현-방식)

[재귀 함수](#재귀-함수)



## SET

### 교집합, 합집합, 차집합

**교집합**

```python
set1 = set([1, 2, 3, 4, 5])
set2 = set([3, 4, 5, 6, 7])

print(set1 & set2)
# {3, 4, 5}
```

**합집합**

```python
set1 = set([1, 2, 3, 4, 5])
set2 = set([3, 4, 5, 6, 7])

print(set1 | set2)
{1, 2, 3, 4, 5, 6, 7}
```

**차집합**

```python
# set1에만 있는 숫자
set1 = set([1, 2, 3, 4, 5])
set2 = set([3, 4, 5, 6, 7])

print (set1 - set2)
# {1, 2}
```

**대칭차집합**

```python
# 교집합이 아닌 숫자들
set1 = set([1, 2, 3, 4, 5])
set2 = set([3, 4, 5, 6, 7])

print(set1 ^ set2)
# {1, 2, 6, 7}
```





## DFS 구현 방식

```python
def dfs(start):
    stack = [start]
    # 현재 정점 방문 처리
    visited[start] = True
    
    # while문으로 스택이 없어질 때까지 진행을 한다
    # while문이 끝났다는 것은, 모든 연결된 정점들이 확인이 되었다는 것
    while stack:
    	# 현재 정점을 스택에서 가지고 온다
    	current = start.pop()
    	
        # graph에서 current 인덱스인 값들을 가지고 온다
    	for adj in graph[current]:
            # visited[adj] 가 False면 True로 변환하고, 스택에 넣는다
            if visited[adj] == False:
                visited[adj] = True
                stack.append(adj)
                # while문이 계속 돌아갈 수 있도록
```





## 재귀 함수

#### 팩토리얼

```python
def factorial(N):
    if N <= 1:
        return 1
    else:
        return N * factorial(N - 1)
        # N! = N * (N-1)!
        # N과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱한다

print(factorial(5))
```

- 재귀 함수를 먼저 호출하면서 stack에 넣는다
  - 예시) [(5 * factorial(4)) , (4 * factorial(3)) , (3 * factorial(2)), (2 * factorial(1)), (factorial(1) return 1)]
    - 마지막은 값이 1이기 때문에 함수 호출을 끝낸다 `n <= 1`
- 호출이 끝내면 stack에서 꺼내면서 반환을 시켜준다
  - (factorial(1) return 1) = 1
  - (2 * factorial(1)) = 2
  - (3 * factorial(2)) = 6
  - (4 * factorial(3)) = 24
  - (5 * factorial(4)) = 120

