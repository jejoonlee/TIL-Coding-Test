# 📋 Python 응용/심화

### Category

[Lambda](#%EF%B8%8F-lambda)



## ✔️ Lambda

> 이름이 없는 (익명)의 함수
>
> lambda *arguments : expression*

**특징**

- return문을 가질 수 없음
- 간편 조건문 외 조건문이나 반복문을 가질 수 없음

**장점**

- 함수를 정의해서 사용하는 것보다 간결하게 사용 가능
- def를 사용할 수 없는 곳에서도 사용가능

```python
numbers = [1, 2, 5, 10, 3, 9, 12]

# 기본 반복/조건 코드
result = []
for n in numbers:
    result.append(n * 3)
print(result)
# [3, 6, 15, 30, 9, 27, 36]

# map을 쓰려면 함수를 정의해야 한다
def multiple_3(n):
    return n * 3
print(list(map(multiple_3, numbers)))
# [3, 6, 15, 30, 9, 27, 36]

# 람다 함수를 사용해 일시적으로 함수를 만들어낸다
print(list(map(lambda n: n * 3, numbers)))
# [3, 6, 15, 30, 9, 27, 36]
```

#### lambda 기본

```python
x = lambda a : a * 5
print(x(5))
# 답 : 25
# x 는 하나의 함수가 된다. x(5) 를 하게 되면, lambda를 통해 5는 a라는 변수 안에 들어가게 된다.
# a는 5와 곱해야 하니깐, 5 * 5 = 25 가 된다
```

#### sort에서 lambda 사용하기

```python
a = [(1, 2), (0, 1), (5, 1), (5, 2), (3, 0)]

# 그냥 sorted를 사용 했을 때에는, 리스트에 있는 tuple의 요소들을 순서대로 정렬을 한다
b = sorted(a)
# b = [(0, 1), (1, 2), (3, 0), (5, 1), (5, 2)]

c = sorted(a, key=lambda x: x[0])
# c = [(0, 1), (1, 2), (3, 0), (5, 1), (5, 2)]
d = sorted(a, key=lambda x: x[1])
# d = [(3, 0), (0, 1), (5, 1), (1, 2), (5, 2)]
```

> `c` 같은 경우 리스트에 있는 tuple의 요소들 중, 첫 번째 인덱스 `x[0]` 기준으로 오름차순으로 정렬한다
>
> - 여기서 첫 번째 인덱스의 값이 같을 경우, 두 번째 인덱스도 오름차순으로 정렬을 하게 된다
>
> `d` 같은 경우 리스트에 있는 tuple의 요소들 중, 두 번째 인덱스 `x[1]` 기준으로 오름차순으로 정렬한다
>
> - 두 번째 인덱스 위주로 오름차순으로 정렬하되, 두 번째 인덱스의 값이 같으면, 첫번째 인덱스에서 오름차순으로 정렬을 한다

```python
# 첫 번째 인덱스는 오름차순 / 두 번째 인덱스는 내림차순으로 구하기

e = [(1, 3), (0, 3), (1, 4), (1, 5), (0, 1), (2, 4)]

f = sorted(e, key=lambda x: (x[0], -x[1]))
# f = [(0, 3), (0, 1), (1, 5), (1, 4), (1, 3), (2, 4)]
```

> `f`를 보면 첫 번째 인덱스는 오름차 순으로, 두 번째 인덱스는 내림차 순으로 정렬된 것을 볼 수 있다
>
> - **전체적으로는 첫 번째 인덱스 기준으로 정렬이 되었다**
