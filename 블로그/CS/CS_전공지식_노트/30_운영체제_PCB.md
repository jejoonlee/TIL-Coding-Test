# 30. 운영체제 [PCB]

*CS 노트*



## PCB (Process Control Block)

> #### 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳이다
>
> - 프로세스의 상태 정보를 저장하는 구조체다
> - PCB는 프로세스 생성시 만들어지고, 주기억장치에 유지된다
>
> #### 커널 스택의 가장 앞부분에서 관리가 된다



### PCB의 구조

- **프로세스 스케줄링 상태** : ready, wait, running 등, 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
- **프로세스 ID** : 프로세스의 고유 번호
- **프로세스 권한** : 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
- **프로그램 카운터** : 프로그램 카운터, 다음 실행될 명령의 포인터
- **CPU 레지스터** : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- **CPU 스케줄링 정보** : CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
- **계정 정보** : CPU 사용시간, 사용량, 실행한 유저의 정보 등
- **I/O 상태 정보** : 입출력 상태 정보 (프로세스에 할당된 I/O 기기 목록 등)





### 컨텍스트 스위칭

> PCB를 교환하는 과정이다
>
> **컨텍스트 (Context)** :  프로그램 카운터, CPU 레지스터들의 값, 메모리 관리 상태 등을 포함한 프로세스의 상태



#### 프로세스에 살당된 시간이 끝나거나 인터럽트에 의해 컨텍스트 스위칭이 발생한다



#### 싱글 코어 기준

- PCB가 매우 빠르게 일어나기 때문에, 싱글 코어 기준에서도, 다수의 프로세스가 한번에 동작하는 것처럼 보인다
- 하지만 현실에서는 싱글 코어를 사용하면, 모든 프로세스들을 컨텍스트 스위칭을 통해, PCB를 교환한다
- 즉 하나의 프로세스만 한번에 동작한다

#### 멀티 코어

- 현대 컴퓨터는 멀티 코어를 사용한다
- 즉 한번에 멀티 프로세스가 돌아갈 수 있다
- 하지만 각 코어마다 하나의 프로세스가 돌아가고, 각가의 코어마다 컨텍스트 스위칭을 한다

![image(1338)](20_운영체제_PCB.assets/image(1338).png)

1. P0 가 실행이 되고 있었는데, interrupt 또는 system call에 의해 방해를 받는다
2. P0 의 상태를 운영체제의 PCB0에 저장을 한다
3. PCB1에 저장되었던 P1의 상태를 불러와서, 실행을 시키킨다
4. P1을 사용하다 또 interrupt 또는 system call에 의해 방해를 받으면 P1의 상태를 PCB1에 저장을 한다
5. PCB0에서 저장되었던 P0 상태를 복구시키고 실행을 한다



#### Overhead (오버헤드)

- 컨텍스트 스위칭이 너무 많이 진행이 되면 과부하가 걸릴 수 있다
- 위에서 P0 상태에서 P1 상태로 컨텍스트 스위칭이 일어날 때
  - P0이 종료될 때까지 기다렸다가 P1 상태로 넘어가면 CPU가 놀고 있게 된다는 것은 CPU 낭비가 된다
    - 기다리는 시간에 P1은 아무것도 안 한다
  - 그 낭비를 감수하고 기존 프로세스에서 새로운 프로세스로 바꾸는 것이다
  - 위에 idle 시간이 겹칠때 오버헤드라고 한다



#### 캐시 미스

- 컨텍스트 스위칭을 할 때 드는 비용이다
- 캐시에 이미 필요한 정보가 저장되어 있으면 좋은데, 그게 아니면 다시 DB에 들어가서 데이터를 찾아야 한다
- 캐시에 필요한 정보가 없어, 캐시 클리어 과정을 겪게 되고, 캐시 미스가 발생한다



#### 스레드에서도 컨텍스트 스위칭이 일어난다. 하지만 스테드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭은 비용과 시간이 더 적게 걸린다
